syntax = "proto3";

import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

// TODO(a.garipov):  Expand the documentation and make it consistent.

/**
 * Service DNSService defines methods for handing servers and devices bound to
 * users' accounts.
 */
service DNSService {
  /**
   * Method getDNSProfiles returns DNS profiles based on the data in the
   * request.
   *
   * The trailers SHOULD include a "sync_time", given in milliseconds, that
   * SHOULD be used for subsequent incremental DNS profile synchronization
   * requests.
   *
   * This method MAY return the following errors:
   * - RateLimitedError: If too many "full sync" concurrent requests are made.
   * - AuthenticationFailedError: If the authentication failed.
   */
  rpc getDNSProfiles(DNSProfilesRequest) returns (stream DNSProfile);

  /**
   * Method saveDevicesBillingStat stores devices activity for billing.
   *
   * This method MAY return the following errors:
   * - AuthenticationFailedError: If the authentication failed.
   */
  rpc saveDevicesBillingStat(stream DeviceBillingStat) returns (google.protobuf.Empty);

  /**
   * Method createDeviceByHumanId creates a device by a profile ID, a human ID,
   * and a device type.
   *
   * This method MAY return the following errors:
   * - RateLimitedError: If the request was made too frequently and the client
   *   must wait before retrying.
   * - DeviceQuotaExceededError: If the client has exceeded its quota for
   *   creating devices.
   * - BadRequestError: If the request is invalid: DNS server does not exist,
   *   creation of auto-devices is disabled or human ID validation failed.
   * - AuthenticationFailedError: If the authentication failed.
   */
  rpc createDeviceByHumanId(CreateDeviceRequest) returns (CreateDeviceResponse);
}

service RateLimitService {
  /*
     Gets rate limit settings.
  */
  rpc getRateLimitSettings(RateLimitSettingsRequest) returns (RateLimitSettingsResponse);

  /*
     Gets global access settings.
  */
  rpc getGlobalAccessSettings(GlobalAccessSettingsRequest) returns (GlobalAccessSettingsResponse);
}

service RemoteKVService {
  /**
     Get the value for the specified key.

     This method may return the following errors:
     - AuthenticationFailedError: If the authentication failed.
  */
  rpc get(RemoteKVGetRequest) returns (RemoteKVGetResponse);

  /**
     Set the value for the specified key.

     This method may return the following errors:
     - AuthenticationFailedError: If the authentication failed.
     - BadRequestError: If the request is invalid: value size exceeds the 512kb.
  */
  rpc set(RemoteKVSetRequest) returns (RemoteKVSetResponse);
}

service CustomDomainService {
  /*
     Get certificate for custom domain.

     This method may return the following errors:
     - AuthenticationFailedError: If the authentication failed.
     - BadRequestError: If the request is invalid: cert_name is empty or no certificate found.
     - NotFoundError: If the certificate was not found.
     - RateLimitedError: If the request was made too frequently and the client must wait before retrying.
  */
  rpc getCustomDomainCertificate(CustomDomainCertificateRequest) returns (CustomDomainCertificateResponse);
}

service SessionTicketService {
  /*
     Gets session ticket for the current date

     This method may return the following errors:
     - AuthenticationFailedError: If the authentication failed.
  */
  rpc getSessionTickets(SessionTicketRequest) returns (SessionTicketResponse);
}

message RateLimitSettingsRequest {}

message RateLimitSettingsResponse {
  repeated CidrRange allowed_subnets = 1;
}

message GlobalAccessSettingsRequest {}

message GlobalAccessSettingsResponse {
  AccessSettings standard = 1;
}

/**
 * Message DNSProfilesRequest contains the data that a DNSService uses to
 * return DNSProfile instances.
 */
message DNSProfilesRequest {
  /**
   * Field sync_time is the start of the interval of required updates. If
   * sync_time is empty, the DNSService returns all data.
   */
  google.protobuf.Timestamp sync_time = 1;
}

/**
 * Message DNSProfile contains both the data of the account and the data of the
 * DNS server.
 *
 * The fields are ordered in a way that optimizes the generated structures'
 * layouts.
 *
 * TODO(a.garipov):  Expand the field documentation.
 */
message DNSProfile {
  // Message fields

  /**
   * Field safe_browsing contains settings for the safe-browsing filters.  If
   * absent, safe-browsing filters are disabled.
   */
  SafeBrowsingSettings safe_browsing = 5;

  ParentalSettings parental = 6;

  /**
   * Field rule_lists contains settings for the rule-list filters.  If absent,
   * the rule-list filtering is disabled.
   */
  RuleListsSettings rule_lists = 7;

  /**
   * Field custom_rule_lists contains settings for the custom rule-list
   * filters.  If absent, the custom rule-list feature is disabled.
   */
  CustomRuleListsSettings custom_rule_lists = 35;

  google.protobuf.Duration filtered_response_ttl = 10;
  AccessSettings access = 18;
  RateLimitSettings rate_limit = 20;
  CustomDomainSettings custom_domain = 22;

  /**
   * Field category_filter contains settings for the category filtering.  If
   * absent, the category filtering is disabled.
   */
  CategoryFilterSettings category_filter = 34;

  // One-of fields

  /**
   * Field blocking_mode defines the blocking mode for general rule-list based
   * filtering.  If field deleted is false, field blocking_mode MUST be
   * present.
   */
  oneof blocking_mode {
    BlockingModeCustomIP blocking_mode_custom_ip = 13;
    BlockingModeNXDOMAIN blocking_mode_nxdomain = 14;
    BlockingModeNullIP blocking_mode_null_ip = 15;
    BlockingModeREFUSED blocking_mode_refused = 16;
  }

  /**
   * Field adult_blocking_mode defines the blocking mode for the adult-content
   * filter.  If absent, the default is used.
   */
  oneof adult_blocking_mode {
    BlockingModeCustomIP adult_blocking_mode_custom_ip = 26;
    BlockingModeNXDOMAIN adult_blocking_mode_nxdomain = 27;
    BlockingModeNullIP adult_blocking_mode_null_ip = 28;
    BlockingModeREFUSED adult_blocking_mode_refused = 29;
  }

  /**
   * Field safe_browsing_blocking_mode defines the blocking mode for the
   * safe-browsing filter.  If absent, the default is used.
   */
  oneof safe_browsing_blocking_mode {
    BlockingModeCustomIP safe_browsing_blocking_mode_custom_ip = 30;
    BlockingModeNXDOMAIN safe_browsing_blocking_mode_nxdomain = 31;
    BlockingModeNullIP safe_browsing_blocking_mode_null_ip = 32;
    BlockingModeREFUSED safe_browsing_blocking_mode_refused = 33;
  }

  // String fields

  /**
   * Field dns_id is the ID of the DNS server.  Not to be confused with the ID
   * of the account, see account_id below.  dns_id MUST be present.
   */
  string dns_id = 1;

  /**
   * Field account_id is a legacy field that should be replaced by
   * account_id_int.  The field's value MUST contain a valid positive integer
   * and MUST be the same as the one in account_id_int.  If field deleted is
   * false, at least one of account_id and account_id_int MUST be set.
   *
   * TODO(a.garipov):  Remove.
   */
  string account_id = 23 [deprecated = true];

  // Repeated fields

  /**
   * Field devices contains the complete list of all devices in the profile, if
   * any.  Fields devices and device_changes MUST NOT be set at the same time,
   * but they MAY both be empty.  Field devices MUST NOT contain duplicates.
   */
  repeated DeviceSettings devices = 8;

  /**
   * Field device_changes contains only the list of changes that have happened
   * to the profile's devices since sync_time, if any.  Fields devices and
   * device_changes MUST NOT be set at the same time, but they MAY both be
   * empty.  Field device_changes MUST NOT contain multiple changes for the
   * same device.
   */
  repeated DeviceSettingsChange device_changes = 24;

  /**
   * Field custom_rules contains custom filtering rules for this DNS server, if
   * any.  All items MUST contain only valid UTF-8 characters and have the size
   * less than or equal to UTF-8 10 000 characters (not bytes).
   */
  repeated string custom_rules = 9;

  // Integer fields

  /**
   * Field account_id_int is the ID of the account to which this DNS server
   * belongs.  It should be used instead of account_id.  The field's value MUST
   * be positive and MUST be the same as in account_id.  If field deleted is
   * false, at least one of account_id and account_id_int MUST be set.
   *
   * TODO(a.garipov):  Rename after removing the current account_id.
   */
  int32 account_id_int = 36;

  // Boolean fields

  bool auto_devices_enabled = 19;

  bool block_chrome_prefetch = 21;

  bool block_firefox_canary = 12;

  bool block_private_relay = 11;

  /**
   * Field deleted, if true, means that this DNS server has been deleted.  All
   * other fields except dns_id SHOULD be absent.
   */
  bool deleted = 4;

  /**
   * Field filtering_enabled defines whether queries from devices of this
   * profile are filtered in any way at all.
   *
   * NOTE:  Field DeviceSettings.filtering_enabled MUST also be true to enable
   * filtering for a particular device.
   */
  bool filtering_enabled = 2;

  /**
   * Field ip_log_enabled defines whether client IP addresses are logged in the
   * query log.
   */
  bool ip_log_enabled = 17;

  /**
   * Field query_log_enabled defines whether query logs are saved for the
   * devices of this profile.
   */
  bool query_log_enabled = 3;

  /**
   * Field query_log_stream defines whether query logs are streamed for the
   * devices of this profile.
   */
  bool query_log_stream = 37;

  bool standard_access_settings_enabled = 25;
}

message DeviceSettingsChange {
  message Deleted {
    string device_id = 1;
  }

  message Upserted {
    DeviceSettings device = 1;
  }

  oneof change {
    Deleted deleted = 1;
    Upserted upserted = 2;
  }
}

message CustomDomainSettings {
  repeated CustomDomain domains = 1;
  bool enabled = 2;
}

/**
 * Custom domain.
 *
 * <p>Field <code>domains</code> must not be empty</p>
 */
message CustomDomain {
  message Pending {
    string well_known_path = 1;
    google.protobuf.Timestamp expire = 2;
  }

  message Current {
    string cert_name = 1;
    google.protobuf.Timestamp not_before = 2;
    google.protobuf.Timestamp not_after = 3;
    bool enabled = 4;
  }

  repeated string domains = 1;
  oneof state {
    Pending pending = 2;
    Current current = 3;
  }
}

/**
 * Message SafeBrowsingSettings contains settings for the safe-browsing
 * filters.
 *
 * The fields are ordered in a way that optimizes the generated structures'
 * layouts.
 */
message SafeBrowsingSettings {
  /**
   * Field typosquatting contains settings for the typosquatting filter.  If
   * absent, the typosquatting filter is disabled.
   */
  TyposquattingFilterSettings typosquatting = 4;

  /**
   * Field block_dangerous_domains, if true, enables the dangerous-domains filter.
   *
   * NOTE:  Fields DNSProfile.filtering_enabled,
   * DeviceSettings.filtering_enabled, and SafeBrowsingSettings.enabled MUST
   * also be true to enable the dangerous-domain filter.
   */
  bool block_dangerous_domains = 2;

  /**
   * Field block_nrd, if true, enabled the newly-registered domains filter.
   *
   * NOTE:  Fields DNSProfile.filtering_enabled,
   * DeviceSettings.filtering_enabled, and SafeBrowsingSettings.enabled MUST
   * also be true to enable the newly-registered domain filter.
   */
  bool block_nrd = 3;

  /**
   * Field enabled, if true, enables safe-browsing filters.
   *
   * NOTE:  Fields DNSProfile.filtering_enabled and
   * DeviceSettings.filtering_enabled MUST also be true to enable safe-browsing
   * filters.
   */
  bool enabled = 1;
}

/**
 * Message DeviceSettings contains the data of a device.
 *
 * The fields are ordered in a way that optimizes the generated structures'
 * layouts.
 *
 * TODO(a.garipov):  Expand the field documentation.
 */
message DeviceSettings {
  AuthenticationSettings authentication = 6;

  string id = 1;

  string name = 2;

  /**
   * Field human_id_lower contains the lowercased value of the Human ID used to
   * create the device, if any.  The field's value is empty for ordinary
   * devices and non-empty for automatically created devices.
   */
  string human_id_lower = 7;

  bytes linked_ip = 4;

  repeated bytes dedicated_ips = 5;

  /**
   * Field filtering_enabled defines whether queries from this device are
   * filtered in any way at all.
   *
   * NOTE:  Field DNSProfile.filtering_enabled MUST also be true to enable
   * filtering for a particular device.
   */
  bool filtering_enabled = 3;
}

message ParentalSettings {
  bool enabled = 1;
  bool block_adult = 2;
  bool general_safe_search = 3;
  bool youtube_safe_search = 4;
  repeated string blocked_services = 5;
  ScheduleSettings schedule = 6;
}

message ScheduleSettings {
  string tmz = 1;
  WeeklyRange weekly_range = 2;
}

message WeeklyRange {
  DayRange mon = 1;
  DayRange tue = 2;
  DayRange wed = 3;
  DayRange thu = 4;
  DayRange fri = 5;
  DayRange sat = 6;
  DayRange sun = 7;
}

message DayRange {
  google.protobuf.Duration start = 1;
  google.protobuf.Duration end = 2;
}

/**
 * Message RuleListsSettings contains settings for the rule-list filters.
 *
 * The fields are ordered in a way that optimizes the generated structures'
 * layouts.
 */
message RuleListsSettings {
  /**
   * Field ids contains unique identifiers of the rule-list filters being used.
   * IDs MUST be unique, between 1 and 128 bytes long, and only contain ASCII
   * symbols with no slashes.
   */
  repeated string ids = 2;

  /**
   * Field enabled, if true, enables the rule-list filter feature.
   */
  bool enabled = 1;
}

/**
 * Message CustomRuleListsSettings contains settings for the custom rule-list
 * filters.
 *
 * The fields are ordered in a way that optimizes the generated structures'
 * layouts.
 */
message CustomRuleListsSettings {
  /**
   * Field ids contains unique identifiers of the rule-list filters being used.
   * IDs MUST be unique, between 1 and 128 bytes long, and only contain ASCII
   * symbols with no slashes.
   *
   * It is recommended that these IDs are distinct from RuleListsSettings.ids.
   * For example, use a standardized prefix like "custom_".
   */
  repeated string ids = 2;

  /**
   * Field enabled, if true, enables the custom rule-list filter feature.
   */
  bool enabled = 1;
}

/**
 * Message BlockingModeCustomIP contains custom IP addresses typically leading
 * to a blocking page.
 */
message BlockingModeCustomIP {
  /**
   * Field ipv4 defines the IPv4 address to use to respond to a blocked
   * request.  If absent, blocked A requests are responded with a NODATA
   * response.
   */
  bytes ipv4 = 1;

  /**
   * Field ipv6 defines the IPv6 address to use to respond to a blocked
   * request.  If absent, blocked AAAA requests are responded with a NODATA
   * response.
   */
  bytes ipv6 = 2;
}

message BlockingModeNXDOMAIN {}

message BlockingModeNullIP {}

message BlockingModeREFUSED {}

message DeviceBillingStat {
  google.protobuf.Timestamp last_activity_time = 1;
  string device_id = 2;
  string client_country = 3;
  // Field proto is the protocol type.
  //
  // See https://github.com/AdguardTeam/AdGuardDNS/blob/master/doc/querylog.md#properties-p.
  uint32 proto = 4;
  uint32 asn = 5;
  uint32 queries = 6;
}

message AccessSettings {
  repeated CidrRange allowlist_cidr = 1;
  repeated CidrRange blocklist_cidr = 2;
  repeated uint32 allowlist_asn = 3;
  repeated uint32 blocklist_asn = 4;
  repeated string blocklist_domain_rules = 5;
  bool enabled = 6;
}

message CidrRange {
  bytes address = 1;
  uint32 prefix = 2;
}

message AuthenticationSettings {
  bool doh_auth_only = 1;
  oneof doh_password_hash {
    bytes password_hash_bcrypt = 2;
  }
}

enum DeviceType {
  INVALID = 0;
  WINDOWS = 1;
  ANDROID = 2;
  MAC = 3;
  IOS = 4;
  LINUX = 5;
  ROUTER = 6;
  SMART_TV = 7;
  GAME_CONSOLE = 8;
  OTHER = 9;
}

message CreateDeviceRequest {
  string dns_id = 1;
  string human_id = 2;
  DeviceType device_type = 3;
}

message CreateDeviceResponse {
  DeviceSettings device = 1;
}

message RateLimitedError {
  string message = 1;
  google.protobuf.Duration retry_delay = 2;
}

message DeviceQuotaExceededError {
  string message = 1;
}

message BadRequestError {
  string message = 1;
}

message AuthenticationFailedError {
  string message = 1;
}

message NotFoundError {
  string message = 1;
}

message RateLimitSettings {
  bool enabled = 1;
  uint32 rps = 2;
  repeated CidrRange client_cidr = 3;
}

message RemoteKVGetRequest {
  string key = 1;
}

message RemoteKVGetResponse {
  oneof value {
    bytes data = 1;
    google.protobuf.Empty empty = 2;
  }
}

message RemoteKVSetRequest {
  string key = 1;
  bytes data = 2;
  google.protobuf.Duration ttl = 3;
}

message RemoteKVSetResponse {}

message CustomDomainCertificateRequest {
  string cert_name = 1;
}

message CustomDomainCertificateResponse {
  bytes certificate = 1;
  bytes private_key = 2;
}

message SessionTicketRequest {}

message SessionTicketResponse {
  repeated SessionTicket tickets = 1;
}

message SessionTicket {
  string name = 1;
  bytes data = 2;
}

/**
 * Message CategoryFilterSettings contains settings for the category filtering.
 *
 * The fields are ordered in a way that optimizes the generated structures'
 * layouts.
 */
message CategoryFilterSettings {
  /**
   * Field ids contains unique identifiers of the categories being blocked.
   * IDs MUST be unique, between 1 and 128 bytes long, and only contain ASCII
   * symbols with no slashes.
   */
  repeated string ids = 2;

  /**
   * Field enabled, if true, enables the category filter feature.
   */
  bool enabled = 1;
}

/**
 * Service FilterIndexService defines methods for requesting indexes of filters
 * and their global settings.
 *
 * TODO(a.garipov):  Add RuleListFilterIndex.
 */
service FilterIndexService {
  /**
   * Method getTyposquattingFilterIndex returns the global-domain filter
   * index and settings.
   *
   * TODO(a.tropnikov):  Document errors.
   */
  rpc getTyposquattingFilterIndex(TyposquattingFilterIndexRequest) returns (TyposquattingFilterIndexResponse);
}

/**
 * Message TyposquattingFilterIndexRequest contains the data to use to obtain
 * the typosquatting filter index.
 *
 * TODO(a.garipov):  Add fields if necessary.
 */
message TyposquattingFilterIndexRequest {}

/**
 * Message TyposquattingFilterIndexResponse contains the data about the
 * typosquatting filter index.
 */
message TyposquattingFilterIndexResponse {
  /**
   * Field index contains the current index of protected domains and other
   * settings for the typosquatting filter.
   */
  TyposquattingFilterIndex index = 1;
}

/**
 * Message TyposquattingFilterSettings contains settings for the typosquatting
 * filter.
 *
 * NOTE:  Fields DNSProfile.filtering_enabled, DNSProfile.safe_browsing.enabled
 * and DeviceSettings.filtering_enabled MUST also be true to enable the
 * typosquatting filter for a particular device.
 */
message TyposquattingFilterSettings {
  /**
   * Field enabled, if true, enables the typosquatting filter feature.
   */
  bool enabled = 1;
}

/**
 * Message TyposquattingFilterIndex contains domains that must be protected by
 * the typosquatting filter, exceptions, etc.
 */
message TyposquattingFilterIndex {
  /**
   * Message TyposquattingFilterIndex.ProtectedDomain represents information
   * about a single protected domain.
   */
  message ProtectedDomain {
    /**
     * Field domain is the protected domain name, for example "google.com".  It
     * MUST NOT be empty and the value MUST be a valid domain name.  It SHOULD
     * be an eTLD+1 domain.
     */
    string domain = 1;

    /**
     * Field distance defines the minimal Damerau–Levenshtein distance to use
     * when matching against the domain.
     *
     * For example, if distance = 1 and domain = "google.com" then "gogle.com",
     * "gooogle.com", and "gogole.com" will match, but "ggle.com",
     * "goooogle.com", and "ggoole.com" won't.
     *
     * It MUST be positive.
     */
    uint32 distance = 2;
  }

  /**
   * Message TyposquattingFilterIndex.Exception is a single exception to the
   * typosquatting filter.  For example, if TyposquattingFilterIndex.domains
   * contains "www.google.com", an exception might be "www.google.co".
   */
  message Exception {
    /**
     * Field domain is the domain name that isn't checked by the typosquatting
     * filter.  It MUST NOT be empty and the value MUST be a valid domain name.
     * It SHOULD be an eTLD+1 domain.
     */
    string domain = 1;
  }

  /**
   * Field domains contains the data about domain names protected by the
   * typosquatting filter.
   */
  repeated ProtectedDomain domains = 1;

  /**
   * Field exceptions contains the data about exceptions to the typosquatting
   * filter.
   */
  repeated Exception exceptions = 2;
}
